\documentclass{article}

\usepackage[utf8]{inputenc}

\title{%
    Procedural World Generation in Unity 5
\\ \large GEDE Spring 2016}
\author{Darri Konráðsson, Einar Gissurarson, Steve Losh}

\date{\today}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{units}

\usepackage{textcomp}
\usepackage{gensymb}
\usepackage{graphicx}
\usepackage{subfig}

\usepackage{hyperref} % have to load hyperref before apacite because latex is a joke
\usepackage{apacite}

\usepackage[a4paper,hmargin=3.0cm,vmargin=3.0cm,bindingoffset=0.0cm]{geometry}

\newcommand\fnurl[2]{%
  \href{#2}{#1}\footnote{\url{#2}}%
}

\begin{document}
\maketitle

\section{Introduction}
\label{sec:intro}

In our project we used the Unity engine (version 5).  Instead of making a single
scene we wrote a few pieces of code that work together to procedurally generate
large, atmospheric terrains for players to explore.

We used a number of freely available assets in our demo.  Some were from the
standard assets included in Unity itself, and we also used the following free
asset packs from the Unity Asset Store:

\begin{enumerate}
    \item{\fnurl{Wispy Sky Box by Mundus Limited}{https://www.assetstore.unity3d.com/en/\#!/content/21737}}
    \item{\fnurl{Yughues Free Ground Materials by Nobiax/Yughues}{https://www.assetstore.unity3d.com/en/\#!/content/13001}}
    \item{\fnurl{Yughues Free Nature Materials by Nobiax/Yughues}{https://www.assetstore.unity3d.com/en/\#!/content/13237}}
    \item{\fnurl{Terrain Textures - Snow - Free Samples by Stroboskop}{https://www.assetstore.unity3d.com/en/\#!/content/54630}}
\end{enumerate}

To learn how to create code for Unity we used several courses on Udemy as well
as research papers (cited later):

\begin{enumerate}
    \item{\fnurl{Learn to Code by Making Games}{https://www.udemy.com/unitycourse/}}
    \item{\fnurl{Creating Meshes with Code in Unity}{https://www.udemy.com/proceduralgeneration/}}
\end{enumerate}

\section{Noise}
\label{sec:noise}

We build our heightmap, by giving randomized values to the Y co-ordinates in a (X,Y,Z) grid. Obviously, putting a completly randomized number in each co-ordinate isn't gonna give us an interesting surface, so we need to implement some form of gradient calculation, to smooth things out. For this we use {\fnurl{Perlin Noise}{https://en.wikipedia.org/wiki/Perlin_noise\#!/content/54630}}. Furthermore, by calculating several instances of Perlin Nose and adding them on top of each other, we create a fractal Perlin Noise that gives us a much more organic look to the height map.

\section{Erosion}
\label{sec:erosion}

Heightmaps generated by noise functions are a good starting point, but they have
a few problems:

\begin{enumerate}
    \item{They look a bit \textit{too} random and unnatural.}
    \item{They are usually fairly uniform, lacking interesting features.}
    \item{They are often lack large flat areas ideal for gameplay.}
\end{enumerate}

Erosion algorithms fix these problems by simulating natural erosion over time.
For this project Steve implemented two erosion algorithms first described
by~\citeA{Musgrave} and expanded on by~\citeA{rtpg}.

\subsection{Thermal Erosion}
\label{subsec:thermal}

Thermal erosion~\cite{Musgrave} simulates wind and gravity pulling rocks down
from steep cliffs and leaving them at the bottom.  It works by iterating through
each point in the heightmap and checking the slope to each of its neighbors, and
if that slope exceeds a certain threshold (called the ``talus angle'') some
material is moved to the lowest neighbor.  This is fairly fast and smooths sharp
cliffs into rolling hills.

A problem with thermal erosion is that although it simulates nature, it doesn't
necessarily produce ideal results for use in games~\cite{rtpg}.  Ideal terrains
for games generally have lots of flat areas for players to run around on and
dramatic cliffs and other landmarks for visual interest.  Thermal erosion
produces almost exactly the opposite of this, but simply flipping a single
``less than'' check lets us perform ``reverse thermal erosion'', which smooths
out moderately-flat areas.

\subsection{Hydraulic Erosion}
\label{subsec:hydraulic}

Hydraulic erosion~\cite{Musgrave} simulates rainfall across the terrain.  Rain
is added on every iteration which dissolves soil, moves it to lower elevations,
and deposits it.

Hydraulic erosion produces natural-looking results (carving out lakes and
riverbeds), but takes much longer to run than thermal erosion.  A good
compromise is to combine all three erosion algorithms:

\begin{enumerate}
    \item{First run reverse thermal erosion to get large, gameplay-friendly features.}
    \item{Next run hydraulic erosion to carve out riverbeds and ponds naturally.}
    \item{Finally run a small amount of normal thermal erosion to smooth off the rough edges produced by the previous steps.}
\end{enumerate}

\section{Vegetation}
\label{sec:vegetation}

Procedural vegetation is used to make the terrain look more natural.  This includes texturing our terrain and adding 3D tree objects.

\subsection{Texturing}
\label{sec:texturing}

Textures serve as the background image on the terrain. Texturing with the painting tool is really time consuming, especially when the terrain gets bigger. A script was created to texture the terrain automatically, depending on the height and slope.

\subsubsection{Height texturing}
\label{sec:heightTexture}

Height texturing works by iterating through every point in the heightmap and adding a texture to this particular point depending on its height.

Terrain below the water surface has its own separate texture. The height of the water surface is declared from a global value by the user.

Mountain peaks also have their own texture (usually snow). The height of the mountain top is also declared from a global value by the user. The texture fades out from top to bottom.


\subsubsection{Slope texturing}
\label{sec:slopeTexture}

Slope texturing works almost like the height texturing but for each point, its neighbor points are checked and the height difference is calculated to get their slope. Textures are then added to the terrain depending on the slope.

\subsection{Adding trees}
\label{sec:trees}

Trees can be added to the terrain to make it look more natural. The trees in Unity 5 are solid 3D objects that grow from the surface. Billboarding (a type of optimisation) is used by Unity to maintain a good rendering performance. Instead of manually painting the trees on the terrain, a script was created to automatically add them. It works by checking if the terrain is flat (same as the slope and height texturing) and assigning random trees to the terrain. Fewer trees are added where the height value of the terrain is high. As the height increases the oxygen gets thinner so the height of the trees also tend to be smaller.

\section{Water}
\label{sec:water}

Out waterplane was generated from the standard assets library in Unity. However, since the plane is only visible from one side, a script was made that flips it 180 degrees, when the player crosses the plane, making it visible from the underside as well. The underwater environment was then created using a script, that modifies the Global Fog variable, reducing visibilty and turning everything a shade of blue. The further down you go in the water, the darker and thicker the fog becomes, to simulate less light traveling down the water. Lastly, we have a projector using a homebrewed shader, to create caustic light effects. The shader allows us to set the scale of the caustics and to set up gradual far clipping, allowing us to resize the projector to fit any plane as well as give a realistic illusion of less light traveling to deeper water.

\bibliographystyle{apacite}
\bibliography{references}

\end{document}
